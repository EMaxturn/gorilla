{"id": "simple_19", "result": "math.gcd<function name=\"math.gcd\"><param name=\"num1\"><type>integer</type></param><param name=\"num2\"><type>integer</type></param></li>", "input_token_count": 428, "output_token_count": 41, "latency": 0.4707660675048828}
{"id": "simple_25", "result": "```json\n[\n  \"calculate_final_velocity\",\n  {\"name\": \"height\", \"parameters\": {\"type\": \"integer\", \"properties\": {\"value\": 150}}, \"required\": true}\n]\n```", "input_token_count": 511, "output_token_count": 51, "latency": 0.5424783229827881}
{"id": "simple_58", "result": "```json\n[{'name': 'cell_biology.function_lookup', 'description': 'Look up the function of a given molecule in a specified organelle. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'molecule': {'type': 'string', 'description': 'The molecule of interest.'}, 'organelle': {'type': 'string', 'description': 'The organelle of interest.'}, 'specific_function': {'type': 'boolean', 'description': 'If set to true, a specific function of the molecule within the organelle will be provided, if such information exists.'}}, 'required': ['molecule', 'organelle', 'specific_function']}}]\n```", "input_token_count": 478, "output_token_count": 157, "latency": 1.3312468528747559}
{"id": "simple_94", "result": "```json\n[{'name': 'update_user_info', 'description': 'Update user information in the database. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'user_id': {'type': 'integer', 'description': 'The user ID of the customer.'}, 'update_info': {'type': 'dict', 'properties': {'name': {'type': 'string', 'description\": \"The customer's updated name.\"}, 'email': {'type': 'string', 'description\": \"The customer's updated email.\"}, 'description': 'The new information to update.'}, 'database': {'type': 'string', 'description': \"The database where the user's information is stored.\", 'default': 'CustomerInfo'}, 'required': ['user_id', 'update_info']}}]\n```", "input_token_count": 533, "output_token_count": 185, "latency": 1.4720933437347412}
{"id": "simple_96", "result": "```json\n[{'name': 'database.query', 'description': 'Query the database based on certain conditions. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'table': {'type': 'string', 'description': 'Name of the table to query.'}, 'conditions': {'type': 'array', 'items': {'type': 'dict', 'properties': {'field': {'type': 'string', 'description': 'The field to apply the condition.'}, 'operation': {'type': 'string', 'description': 'The operation to be performed.', 'enum': ['<', '>', '=', '>=', '<=']}, 'value': {'type': 'string', 'description': 'The value to be compared.'}}, 'required': ['field', 'operation', 'value']}, 'description': 'Conditions for the query.'}}, 'required': ['table', 'conditions']}\n```", "input_token_count": 532, "output_token_count": 199, "latency": 1.5419070720672607}
{"id": "simple_105", "result": "math.power(3, 4)\n", "input_token_count": 456, "output_token_count": 11, "latency": 0.12766647338867188}
{"id": "simple_113", "result": "probability.dice_roll(desired_number=6, number_of_rolls=2)\n", "input_token_count": 500, "output_token_count": 22, "latency": 0.2529125213623047}
{"id": "simple_134", "result": "```json\n{'investment.predictProfit': {'input': {'investment_amount': 5000, 'annual_return': 0.07, 'years': 5}, 'type': 'dict'}, 'total_expected_profit': {'input': {'investment_amount': 5000, 'annual_return': 0.07, 'years': 5}, 'type': 'dict'}}\n```", "input_token_count": 485, "output_token_count": 93, "latency": 0.8396186828613281}
{"id": "simple_155", "result": "```json\n[{'name': 'calculate_future_value', 'description': 'Calculate the future value of an investment given the initial amount, interest rate, and investment duration. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'initial_investment': {'type': 'integer', 'description': 'The initial investment amount.'}, 'interest_rate': {'type': 'float', 'description': 'The annual interest rate in decimal form.'}, 'duration': {'type': 'integer', 'description': 'The investment duration in years.'}, 'compounded': {'type': 'integer', 'description': 'The number of times the interest is compounded per year. Default is 1 (annual compounding).'}}, 'required': ['initial_investment', 'interest_rate', 'duration']}}]\n```python\n[{'name': 'calculate_future_value', 'description': 'Calculate the future value of an investment given the initial amount, interest rate, and investment duration. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'initial_investment': {'type': 'integer', 'description': 'The initial investment amount.'}, 'interest_rate': {'type': 'float', 'description': 'The annual interest rate in decimal form.'}, 'duration': {'type': 'integer', 'description': 'The investment duration in years.'}, 'compounded': {'type': 'integer', 'description': 'The number of times the interest is compounded per year. Default is 1 (annual compounding).'}}, 'required': ['initial_investment', 'interest_rate', 'duration']}}]\n```", "input_token_count": 518, "output_token_count": 358, "latency": 2.258291482925415}
{"id": "simple_165", "result": "```json\n[{'name': 'civil_cases.retrieve', 'description': 'Retrieve civil cases based on given parameters, including year, crime type, and location. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'year': {'type': 'integer', 'description': 'Year of the cases'}, 'crime_type': {'type': 'string', 'description': 'Type of the crime.'}, 'location': {'type': 'string', 'description': 'Location of the case in the format of city name.'}}, 'required': ['year', 'crime_type', 'location']}}]\n```", "input_token_count": 468, "output_token_count": 141, "latency": 1.1683380603790283}
{"id": "simple_168", "result": "```json\n[\n  \"lawsuit_search\",\n  {\"name\": \"lawsuit_search\", \"description\": \"Search for lawsuits related to a specific company within a specific date range and location. Note that the provided function is in Python 3 syntax.\", \"parameters\": {\"type\": \"dict\", \"properties\": {\"company\": {\"type\": \"string\", \"description\": \"The company related to the lawsuit.\"}, \"start_date\": {\"type\": \"string\", \"description\": \"Start of the date range for when the lawsuit was filed in the format of MM-DD-YYY.\"}, \"location\": {\"type\": \"string\", \"description\": \"Location where the lawsuit was filed in the format of full state name.\"}, \"status\": {\"type\": \"string\", \"enum\": [\"ongoing\", \"settled\", \"dismissed\"], \"description\": \"The status of the lawsuit. Default is 'ongoing'.\"}}, \"required\": [\"company\", \"start_date\", \"location\"]}\n]\n```", "input_token_count": 537, "output_token_count": 209, "latency": 1.5618505477905273}
{"id": "simple_174", "result": "```json\n[\n  \"get_top_cases\",\n  \"{\"name\": \"get_top_cases\", \"description\": \"Retrieve a list of the most influential or landmark cases in a specific field of law. Note that the provided function is in Python 3 syntax.\", \"parameters\": {\"type\": \"dict\", \"properties\": {\"field_of_law\": {\"type\": \"string\", \"description\": \"The specific field of law e.g., constitutional law, criminal law, etc.\"}, \"top_number\": {\"type\": \"integer\", \"description\": \"The number of top cases to retrieve.\"}, \"country\": {\"type\": \"string\", \"description\": \"The country where the law cases should be retrieved from. Default is United States of America.\"}}, \"required\": [\"field_of_law\", \"top_number\"]}\"]\n]\n```", "input_token_count": 495, "output_token_count": 183, "latency": 1.4140448570251465}
{"id": "simple_179", "result": "```json\n[\n  \"find_latest_court_case\",\n  {\"name\": \"find_latest_court_case\", \"description\": \"Find the latest court case between two companies. Note that the provided function is in Python 3 syntax.\", \"parameters\": {\"type\": \"dict\", \"properties\": {\"company1\": {\"type\": \"string\", \"description\": \"The name of the first company.\"}, \"company2\": {\"type\": \"string\", \"description\": \"The name of the second company.\"}, \"country\": {\"type\": \"string\", \"description\": \"The country in which the court case is located.\", \"default\": \"USA\"}}, \"required\": [\"company1\", \"company2\"]}}\n]\n```", "input_token_count": 466, "output_token_count": 155, "latency": 1.2529892921447754}
{"id": "simple_181", "result": "```json\n[{'name': 'get_lawsuit_details', 'description': 'Retrieve details of a lawsuit based on its case number and court location. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'case_number': {'type': 'string', 'description': 'Case number of the lawsuit.'}, 'court_location': {'type': 'string', 'description': 'The location of the court where the lawsuit was filed.'}, 'with_verdict': {'type': 'boolean', 'description': 'Flag to include verdict details if available. Default is False'}}, 'required': ['case_number', 'court_location']}}]\n```", "input_token_count": 488, "output_token_count": 152, "latency": 1.2240118980407715}
{"id": "simple_208", "result": "map_service.get_directions('New York', 'Los Angeles', 'highways', 'toll roads')", "input_token_count": 495, "output_token_count": 24, "latency": 0.26972532272338867}
{"id": "simple_213", "result": "flight.book({'departure_location': 'San Francisco', 'destination_location': 'London', 'date': '2022-04-27', 'time': 'afternoon', 'direct_flight': True})", "input_token_count": 552, "output_token_count": 50, "latency": 0.49007606506347656}
{"id": "simple_226", "result": "```json\n[\n  \"get_zodiac_compatibility\",\n  {\"name\": \"sign1\", \"param\": {\"type\": \"string\", \"description\": \"The first Zodiac sign.\"}, \"sign2\": {\"type\": \"string\", \"description\": \"The second Zodiac sign.\"}, \"scale\": {\"type\": \"string\", \"enum\": [\"percentage\", \"0-10 scale\"], \"description\": \"The scale on which compatibility should be shown. Default is 'percentage'.\"}}\n]\n```", "input_token_count": 470, "output_token_count": 108, "latency": 0.9220631122589111}
{"id": "simple_244", "result": "publication_year.find('law of universal gravitation')\n{'type': 'dict', 'properties': {'author': {'type': 'string', 'description': 'Name of the author of the work.'}, 'work_title': {'type': 'string', 'description': 'Title of the scientific work.'}, 'location': {'type': 'string', 'description\": \"Place of the publication, if known. Default to 'all'.\"}}, 'required': ['author', 'work_title']}", "input_token_count": 463, "output_token_count": 104, "latency": 0.888953447341919}
{"id": "simple_254", "result": "```json\n[\n  \"get_religion_history\",\n  {\"religion\": \"Christianity\", \"start_year\": 300, \"end_year\": 400, \"event_type\": \"all\"}\n]\n```", "input_token_count": 523, "output_token_count": 55, "latency": 0.5250487327575684}
{"id": "simple_281", "result": "```json\n{'get_instrument_info': {'name': 'Violin', 'maker': 'Stradivarius', 'year': 1721}}\n```", "input_token_count": 483, "output_token_count": 38, "latency": 0.37758755683898926}
{"id": "simple_284", "result": "```json\n[{'name': 'concert_info.get', 'description': 'Retrieve information about concerts based on specific genre, location and date. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'location': {'type': 'string', 'description': 'The city where the concert will take place.'}, 'date': {'type': 'string', 'description': 'Time frame to get the concert for.'}, 'genre': {'type': 'string', 'description': 'Genre of the concert.', 'enum': ['Pop', 'Rock', 'Country', 'Classical', 'Electronic', 'Hip-Hop']}}, 'required': ['location', 'date', 'genre']}}]\n```", "input_token_count": 482, "output_token_count": 158, "latency": 1.214073657989502}
{"id": "simple_295", "result": "```json\n[\n  \"get_song_lyrics\",\n  {\"name\": \"get_song_lyrics\", \"description\": \"Retrieve the lyrics of a song based on the artist's name and song title. Note that the provided function is in Python 3 syntax.\", \"parameters\": {\"type\": \"dict\", \"properties\": {\"song_title\": {\"type\": \"string\", \"description\": \"The title of the song.\"}, \"artist_name\": {\"type\": \"string\", \"description\": \"The name of the artist who performed the song.\"}, \"lang\": {\"type\": \"string\", \"description\": \"The language of the lyrics. Default is English.\", \"enum\": [\"English\", \"French\", \"Spanish\", \"German\", \"Italian\"]}}, \"required\": [\"song_title\", \"artist_name\"]}}\n]\n```", "input_token_count": 492, "output_token_count": 177, "latency": 1.321138620376587}
{"id": "simple_297", "result": "```json\n[{'name': 'music.theory.chordProgression', 'description': 'Identifies a potential key signature for the given chord progression. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'progression': {'type': 'array', 'items': {'type': 'string'}, 'description': \"The chord progression in Roman numerals. Eg: ['I', 'V', 'vi', 'IV'].\"}, 'returnAllPossibleKeys': {'type': 'boolean', 'description': 'Flag indicating if the function should return all possible key signatures that fit the chord progression. If false, the function will return the first valid key it finds. Default is false.'}, 'assumeMajor': {'type': 'boolean', 'description': 'Assumption if the key signature is Major. If true, the function will assume the key signature to be major and otherwise minor. Default is true.'}}, 'required': ['progression']}}]\n```", "input_token_count": 541, "output_token_count": 208, "latency": 1.4685287475585938}
{"id": "simple_327", "result": "sports_team.get_schedule(team_name='Manchester United', num_of_games=6, league='Premier League')", "input_token_count": 544, "output_token_count": 29, "latency": 0.2811744213104248}
{"id": "simple_328", "result": "```json\n{'name': 'boardgame.get_info', 'description': 'Retrieve detailed information of a board game. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'name': {'type': 'string', 'description': 'Name of the board game.'}, 'parameters': {'type': 'array', 'items': {'type': 'string', 'enum': ['player count', 'playing time', 'age', 'mechanics', 'rating']}, 'description': 'Game characteristics interested.'}, 'language': {'type': 'string', 'description': 'The preferred language for the game information, default is English'}}, 'required': ['name', 'parameters']}\n```", "input_token_count": 484, "output_token_count": 156, "latency": 1.1670832633972168}
{"id": "simple_335", "result": "```json\n[\n  \"find_card_in_deck\",\n  {\"name\": \"find_card_in_deck\", \"description\": \"Locate a particular card in a deck based on rank and suit. Note that the provided function is in Python 3 syntax.\", \"parameters\": {\"type\": \"dict\", \"properties\": {\"rank\": {\"type\": \"string\", \"description\": \"Rank of the card (e.g. Ace, Two, King).\"}, \"suit\": {\"type\": \"string\", \"description\": \"Suit of the card (e.g. Hearts, Spades, Diamonds, Clubs).\"}, \"deck\": {\"type\": \"array\", \"items\": {\"type\": \"dict\", \"properties\": {\"rank\": {\"type\": \"string\"}, 'suit': {\"type\": \"string\"}}}, 'description': 'Deck of cards. If not provided, the deck will be a standard 52 card deck'}, \"required\": [\"rank\", \"suit\"]}}}\n]\n```", "input_token_count": 525, "output_token_count": 212, "latency": 1.4660296440124512}
{"id": "simple_360", "result": "```json\n[\n  \"find_recipe\",\n  {\"name\": \"find_recipe\", \"description\": \"Locate a recipe based on name and its calorie content Note that the provided function is in Python 3 syntax.\", \"parameters\": {\"recipeName\": {\"type\": \"string\", \"description\": \"The recipe's name.\"}, \"maxCalories\": {\"type\": \"integer\", \"description\": \"The maximum calorie content of the recipe.\", \"default\": 1000}}, \"required\": [\"recipeName\"]}\n]\n```", "input_token_count": 442, "output_token_count": 114, "latency": 0.9049248695373535}
{"id": "simple_380", "result": "hotel_booking<function 'hotel_booking'>(location='Manhattan, New York', room_type='single', duration=3, start_date='2023-03-10'):\n", "input_token_count": 596, "output_token_count": 46, "latency": 0.41413116455078125}
{"id": "simple_390", "result": "```json\n{'currency_conversion.convert': {'amount': 150, 'from_currency': 'EUR', 'to_currency': 'CAD'}}\n```", "input_token_count": 456, "output_token_count": 37, "latency": 0.3368721008300781}
{"id": "simple_393", "result": "convert_currency({'name': 'convert_currency', 'description': 'Converts an amount from a particular currency to another currency. Note that the provided function is in Python 3 syntax.', 'parameters': {'type': 'dict', 'properties': {'base_currency': {'type': 'string', 'description': 'The base currency in which the original amount is present.'}, 'target_currency': {'type': 'string', 'description': 'The currency to which you want to convert.'}, 'amount': {'type': 'integer', 'description': 'The amount you want to convert.'}}, 'required': ['base_currency', 'target_currency', 'amount']}})", "input_token_count": 473, "output_token_count": 142, "latency": 1.0760715007781982}
